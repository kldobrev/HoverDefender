#include <gb/gb.h>
#include "cutscenesdialogue.c"
#include "tiles/endingcutsctiles.c"
#include "tiles/fortsfiretiles.c"
#include "maps/endingcutscmap.c"


extern UINT8 i, bossclearflg, stagenum, oamidx;


const UINT8 endingtext[] = {
    0x13, 0x00, 0x0C, 0x0B, 0x1C, 0x0F, 0x16, 0x23, 0x00, 0x17, 0x0B, 0x0E, 0x0F, 0x00, 0x13, 0x1E, 0xFE,
    0x19, 0x1F, 0x1E, 0x00, 0x13, 0x18, 0x00, 0x1E, 0x13, 0x17, 0x0F, 0x27, 0x00, 0x21, 0x0F, 0x16, 0x16, 0x29, 0xFE,
    0x10, 0x19, 0x1C, 0x1E, 0x00, 0x1D, 0x1E, 0x1C, 0x0B, 0x1E, 0x19, 0x1D, 0x00, 0x13, 0x1D, 0x00, 0x18, 0x19, 0xFE,
    0x17, 0x19, 0x1C, 0x0F, 0x26, 0x00, 0x1E, 0x12, 0x0F, 0x00, 0x17, 0x13, 0x16, 0x13, 0x1E, 0x0B, 0x1C, 0x23, 0xFE,
    0x21, 0x13, 0x16, 0x16, 0x00, 0x12, 0x0B, 0x20, 0x0F, 0x00, 0x1E, 0x19, 0xFE,
    0x1C, 0x0F, 0x16, 0x23, 0x00, 0x19, 0x18, 0x00, 0x16, 0x0F, 0x1D, 0x1D, 0xFE,
    0x1A, 0x19, 0x21, 0x0F, 0x1C, 0x10, 0x1F, 0x16, 0x00, 0x21, 0x0F, 0x0B, 0x1A, 0x19, 0x18, 0x1D, 0xFE,
    0x10, 0x19, 0x1C, 0x00, 0x1E, 0x12, 0x0F, 0x00, 0x1E, 0x13, 0x17, 0x0F, 0xFE,
    0x0C, 0x0F, 0x13, 0x18, 0x11, 0x26, 0x00, 0x13, 0x2A, 0x20, 0x0F, 0x00, 0x18, 0x0F, 0x20, 0x0F, 0x1C, 0xFE,
    0x16, 0x13, 0x15, 0x0F, 0x0E, 0x00, 0x1E, 0x12, 0x0B, 0x1E, 0x00, 0x1A, 0x16, 0x0B, 0x0D, 0x0F, 0xFE,
    0x0B, 0x18, 0x23, 0x21, 0x0B, 0x23, 0x26, 0xFE,
    0xFE,
    0x21, 0x12, 0x23, 0x00, 0x21, 0x0B, 0x1D, 0x00, 0x1F, 0x16, 0x1E, 0x11, 0x0F, 0x18, 0xFE,
    0x21, 0x13, 0x16, 0x16, 0x13, 0x18, 0x11, 0x00, 0x1E, 0x19, 0x00, 0x11, 0x19, 0x00, 0x1E, 0x19, 0xFE,
    0x1D, 0x1F, 0x0D, 0x12, 0x00, 0x0F, 0x22, 0x1E, 0x1C, 0x0F, 0x17, 0x0F, 0x1D, 0x00, 0x10, 0x19, 0x1C, 0xFE,
    0x17, 0x19, 0x1C, 0x0F, 0x00, 0x1A, 0x19, 0x21, 0x0F, 0x1C, 0x28, 0xFE,
    0x12, 0x19, 0x21, 0x00, 0x0E, 0x13, 0x0E, 0x00, 0x12, 0x0F, 0x00, 0x11, 0x0F, 0x1E, 0xFE,
    0x1D, 0x19, 0x00, 0x17, 0x0B, 0x18, 0x23, 0x00, 0x1E, 0x19, 0x00, 0x10, 0x19, 0x16, 0x16, 0x19, 0x21, 0xFE,
    0x12, 0x13, 0x17, 0x00, 0x0B, 0x18, 0x0E, 0x00, 0x12, 0x13, 0x1D, 0x00, 0x0D, 0x0B, 0x1F, 0x1D, 0x0F, 0x28, 0xFE,
    0x0B, 0x1E, 0x00, 0x16, 0x0F, 0x0B, 0x1D, 0x1E, 0x00, 0x12, 0x0F, 0x00, 0x21, 0x13, 0x16, 0x16, 0xFE,
    0x18, 0x19, 0x1E, 0x00, 0x1E, 0x1C, 0x0F, 0x0B, 0x1E, 0x0F, 0x18, 0x00, 0x0B, 0x18, 0x23, 0x19, 0x18, 0x0F, 0xFE,
    0x0B, 0x18, 0x23, 0x17, 0x19, 0x1C, 0x0F, 0x26, 0xFE,
    0xFE,
    0x13, 0x00, 0x1A, 0x1C, 0x0F, 0x20, 0x0F, 0x18, 0x1E, 0x0F, 0x0E, 0xFE,
    0x0B, 0x00, 0x11, 0x1C, 0x0F, 0x0B, 0x1E, 0x00, 0x0E, 0x13, 0x1D, 0x0B, 0x1D, 0x1E, 0x0F, 0x1C, 0xFE,
    0x1E, 0x19, 0x0E, 0x0B, 0x23, 0x00, 0x0B, 0x18, 0x0E, 0x00, 0x13, 0x00, 0x0D, 0x19, 0x1F, 0x16, 0x0E, 0xFE,
    0x18, 0x19, 0x1E, 0x00, 0x12, 0x0B, 0x20, 0x0F, 0x00, 0x0E, 0x19, 0x18, 0x0F, 0x00, 0x13, 0x1E, 0xFE,
    0x21, 0x13, 0x1E, 0x12, 0x19, 0x1F, 0x1E, 0x00, 0x23, 0x19, 0x1F, 0x1C, 0x00, 0x12, 0x0F, 0x16, 0x1A, 0x27, 0xFE,
    0x1E, 0x12, 0x0B, 0x18, 0x15, 0x00, 0x23, 0x19, 0x1F, 0x00, 0x10, 0x19, 0x1C, 0xFE,
    0x1D, 0x1E, 0x13, 0x0D, 0x15, 0x13, 0x18, 0x11, 0x00, 0x21, 0x13, 0x1E, 0x12, 0x00, 0x17, 0x0F, 0xFE,
    0x1F, 0x18, 0x1E, 0x13, 0x16, 0x00, 0x1E, 0x12, 0x0F, 0x00, 0x0F, 0x18, 0x0E, 0x27, 0xFE,
    0x13, 0x1E, 0x2A, 0x1D, 0x00, 0x1E, 0x13, 0x17, 0x0F, 0x00, 0x10, 0x19, 0x1C, 0x00, 0x0B, 0xFE,
    0x21, 0x0F, 0x16, 0x16, 0x00, 0x0E, 0x0F, 0x1D, 0x0F, 0x1C, 0x20, 0x0F, 0x0E, 0xFE,
    0x0C, 0x1C, 0x0F, 0x0B, 0x15, 0x26, 0x00, 0x11, 0x19, 0x19, 0x0E, 0x0C, 0x23, 0x0F, 0x27, 0x00, 0x00, 0x00, 0xFE, 0xFF    
};


const UINT8 fires[][3] = {{88, 28, 1}, {96, 26, 0}, {104, 24, 1}, {112, 25, 0}, {120, 26, 1}, {128, 24, 1}, {140, 27, 0}};

UINT8 animitr = 0;


void custom_delay(UINT8 cycles) NONBANKED;
void incr_oam_sprite_tile_idx(INT8 steps) NONBANKED;
void reset_sprites(UINT8 fstsprite, UINT8 lastsprite) NONBANKED;
void scroll_textbox(UINT8 dialidx) BANKED;
UINT8 wait_player_input(UINT8 crsridx) BANKED;
void se_move_cursor2() BANKED;
void hide_win_layer() BANKED;
void display_epilogue() BANKED;
void anim_inverted_bw_to_blackout() BANKED;
void anim_blackout_to_inverted_bw() BANKED;



void scroll_textbox(UINT8 dialidx) BANKED {
    const UINT8 textoffsx = 1;
    const UINT8 exampletext[] = {0x19, 0x17, 0x26, 0x00, 0x26, 0x21, 0x00, 0x26, 0x1A, 0x17, 0x00, 0x15, 0x1A, 0x21, 0x22, 0x22, 0x13, 0x2F};
    // Character limit per line - 18
    fill_win_rect(0, 0, 20, 1, 0x00);
    UINT8 textboxposy = 134;
    move_win(11, 134);
    set_sprite_tile(39, 75);
    set_win_tile_xy(0, 0, 255);

    const UINT8 * textpos = dialoguearr[dialidx];
    if(textpos == NULL) {
        return;
    }
    for(i = 0; *textpos != 0xFF; textpos++, i++) {  // Using 0xFF to indicate text end
        if(*textpos == 0xFE) {  // Using 0xFE to indicate end of line
            fill_win_rect(i + 1, 0, 21 - i, 1, 0x00);
            if(wait_player_input(i) == J_A) {   // Print next line
                i = 255;    // Will be reset to 0 before next iteration
                fill_win_rect(0, 0, 20, 1, 0x00);
                continue;
            } else {    // Stop printing
                break;
            }
        } else if(*textpos > 0xF6) {    // Line with character name
            fill_win_rect(0, 0, 20, 1, 0x00);
            i = *textpos - 0xF7;   // Character name array index
            set_win_tiles(0, 0, nameslengths[i], 1, names[i]);
            i = nameslengths[i] - 1;    // Setting iterator for blinking animation
            continue;
        }
        set_win_tile_xy(i, 0, *textpos);
        set_win_tile_xy(i + 1, 0, 255);
        se_move_cursor2();
        custom_delay(3);
    }
    move_win(15, 134);
}


UINT8 wait_player_input(UINT8 crsridx) BANKED {
    animitr = 0;
    while(1) {
        if(animitr % 32 == 0) {
            set_win_tile_xy(crsridx, 0, 0);
        } else if(animitr % 16 == 0) {
            set_win_tile_xy(crsridx, 0, 255);
        }
        animitr++;
        wait_vbl_done();
        if(joypad() & J_A) {
            waitpadup();
            return J_A;
        } else if(joypad() & J_START) {
            waitpadup();
            return J_START;
        }
    }
}


void hide_win_layer() BANKED {
    HIDE_WIN;
}


void display_epilogue() BANKED {
    reset_sprites(0, 40);
    fill_win_rect(0, 0, 20, 1, 0);
    set_sprite_data(0, 3, fortsfiretiles);
    set_bkg_data(44, 92, endingcutsctiles);
    fill_bkg_rect(0, 0, 20, 18, 0);
    oamidx = 0;
    UINT8 cyclecnt = 1, textx = 1, texty = 20;
    const UINT8 * letter = endingtext;
    set_win_tiles(1, 1, 18, 8, endingcutscmap);
    move_bkg(0, 0);
    move_win(7, 0);
    SHOW_WIN;
    anim_blackout_to_inverted_bw();
    for(i = 0; i != 7; i++) {   // Initiating fire sprites
        move_sprite(oamidx, fires[i][0], fires[i][1]);
        set_sprite_tile(oamidx, fires[i][2]);
        incr_oam_sprite_tile_idx(1);
    }

    STAT_REG = 0x45;
    LYC_REG = 0x4F;
    add_LCD(hide_win_layer);
    enable_interrupts();
    set_interrupts(VBL_IFLAG | LCD_IFLAG);

    while(1) {
        SHOW_WIN;
        if(cyclecnt % 8 == 0) {
            scroll_bkg(0, 1);
            texty = SCY_REG;
            if(texty % 8 == 0) {   // Time to display a line of text
                texty = SCY_REG >> 3;   // Getting bkg tile
                texty = texty + 18 > 32 ? (texty - 32) + 18 : texty + 18;   // Writing text 18 tiles after the current scroll position index
                if(*letter != 0xFF && (texty == 0 || texty % 2 == 0)) {   // There is text to be displayed
                    for(textx = 1; *letter != 0xFE; textx++, letter++) {    // Display a line of text
                        set_bkg_tile_xy(textx, texty, *letter);
                    }
                    fill_bkg_rect(1, texty + 2, 18, 1, 0);  // Erasing the previously written memory before writing
                    letter++;   // Get past the 0xFE
                } else if(*letter == 0xFF) {
                    fill_bkg_rect(1, texty, 18, 1, 0);  // Erasing old text after no more text to display
                    if(SCY_REG > 0xB4) {    // When no more text to display, wait until the scroll gets to y > 180 and break out of loop
                        break;
                    }
                }
            }
        }
        
        if(cyclecnt == 16) {
            for(i = 0; i != 7; i++) {
                set_sprite_tile(i, get_sprite_tile(i) == 0 ? 1 : 0);    // Animate airbase flames
            }
            cyclecnt = 1;
        } else {
            cyclecnt++;
        }
        
        wait_vbl_done();
    }

    SHOW_WIN;
    reset_sprites(0, 7);
    anim_inverted_bw_to_blackout();
    __critical {
        remove_LCD(hide_win_layer);
    }
    move_bkg(0, 0);
    HIDE_WIN;
}


void anim_inverted_bw_to_blackout() BANKED {
    for(UINT8 blkstep = 0; blkstep != 21; blkstep++) {
        switch(blkstep) {
            case 1:
                BGP_REG = 0x67;
                break;
            case 10:
                BGP_REG = 0xAB;
                break;
            case 20:
                BGP_REG = 0xFF;
                break;
        }
        wait_vbl_done();
    }
}


void anim_blackout_to_inverted_bw() BANKED {
    for(UINT8 blkstep = 0; blkstep != 21; blkstep++) {
        switch(blkstep) {
            case 1:
                BGP_REG = 0xBF;
                break;
            case 10:
                BGP_REG = 0x7B;
                break;
            case 20:
                BGP_REG = 0x27;
                break;
        }
        wait_vbl_done();
    }
}


void se_move_cursor2() BANKED {
    NR10_REG = 0x00;
    NR11_REG = 0xCB;
    NR12_REG = 0xF2;
    NR13_REG = 0x9F;
    NR14_REG = 0x86;
}
